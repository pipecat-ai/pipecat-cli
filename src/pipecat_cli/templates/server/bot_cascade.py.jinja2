#
# Copyright (c) 2024–2025, Daily
#
# SPDX-License-Identifier: BSD 2-Clause License
#

"""{{ project_name }} - Pipecat Voice Agent

This bot uses a cascade pipeline: Speech-to-Text → LLM → Text-to-Speech

Generated by Pipecat CLI

Required AI services:
{% if stt_service %}
- {{ stt_service.replace('_stt', '').title() }} (Speech-to-Text)
{% endif %}
{% if llm_service %}
- {{ llm_service.replace('_llm', '').title() }} (LLM)
{% endif %}
{% if tts_service %}
- {{ tts_service.replace('_tts', '').title() }} (Text-to-Speech)
{% endif %}

Run the bot using::

    uv run bot.py
"""

{# Import macros for composition #}
{% import 'server/_macros/event_handlers.jinja2' as handlers %}
{% import 'server/_macros/pipeline_components.jinja2' as pipeline %}
{% import 'server/_macros/helper_functions.jinja2' as helpers %}

{# Standard imports #}
{{ imports|join('\n') }}

{# Daily PSTN and Twilio + Daily SIP specific imports #}
{% if 'daily_pstn_dialin' in transports or 'twilio_daily_sip_dialin' in transports %}
from server_utils import AgentRequest
{% elif 'daily_pstn_dialout' in transports or 'twilio_daily_sip_dialout' in transports %}
from server_utils import AgentRequest, DialoutSettings
{% endif %}

{# Twilio Client import for Twilio + Daily SIP dial-in #}
{% if 'twilio_daily_sip_dialin' in transports %}
from twilio.rest import Client
{% endif %}

load_dotenv(override=True)

{% if recording %}
{{ helpers.save_audio_file_function() }}
{% endif %}

{% if 'twilio' in transports %}
{{ helpers.get_call_info_function() }}
{% endif %}

{% if 'daily_pstn_dialout' in transports or 'twilio_daily_sip_dialout' in transports %}
{{ helpers.dialout_manager_class(transports) }}
{% endif %}

{% if 'daily_pstn_dialout' in transports or 'twilio_daily_sip_dialout' in transports %}
async def run_bot(
    transport: BaseTransport, dialout_settings: DialoutSettings
) -> None:
    """Run the voice bot for an outbound call.

    Sets up the bot pipeline with STT, LLM, and TTS services, then initiates
    the dialout and handles the conversation with retry logic.

    Args:
        transport: Daily transport for the call
        dialout_settings: Phone number and optional caller ID for the outbound call
    """
{% elif 'twilio_daily_sip_dialin' in transports %}
async def run_bot(transport: BaseTransport, request: AgentRequest) -> None:
    """Run the voice bot with the given parameters.

    Args:
        transport: The Daily transport instance
        request: The agent request containing the call details
    """
{% else %}
async def run_bot(transport: BaseTransport):
    """Main bot logic."""
{% endif %}
    logger.info("Starting bot")

    # Speech-to-Text service
    {% if stt_service and stt_service in service_configs %}
    stt = {{ service_configs[stt_service] }}
    {% endif %}

    # Text-to-Speech service
    {% if tts_service and tts_service in service_configs %}
    tts = {{ service_configs[tts_service] }}
    {% endif %}

    # LLM service
    {% if llm_service and llm_service in service_configs %}
    llm = {{ service_configs[llm_service] }}
    {% endif %}

{{ helpers.setup_context() }}

{{ helpers.setup_feature_processors(recording, transcription, bot_type) }}
    
    # Pipeline - assembled from reusable components
{{ pipeline.cascade_pipeline(bot_type, transcription, recording) }}

    task = PipelineTask(
        pipeline,
        params=PipelineParams(
            enable_metrics=True,
            enable_usage_metrics=True,
            {% if bot_type == 'telephony' %}
            audio_in_sample_rate=8000,
            audio_out_sample_rate=8000,
            {% endif %}
        ),
        {% if bot_type == 'web' or enable_observability %}
        observers=[
            {% if bot_type == 'web' %}
            RTVIObserver(rtvi),
            {% endif %}
            {% if enable_observability %}
            WhiskerObserver(pipeline),
            TailObserver(),
            {% endif %}
        ],
        {% endif %}
    )

    {% if 'daily_pstn_dialout' in transports or 'twilio_daily_sip_dialout' in transports %}
    # Initialize dialout manager
    dialout_manager = DialoutManager(transport, dialout_settings)

    {% endif %}
    {# Event handlers - use macros based on transport type #}
    {% if 'daily_pstn_dialin' in transports %}
{{ handlers.daily_pstn_dialin_handlers(recording) }}
    {% elif 'daily_pstn_dialout' in transports %}
{{ handlers.daily_pstn_dialout_handlers(recording) }}
    {% elif 'twilio_daily_sip_dialin' in transports %}
{{ handlers.twilio_daily_sip_dialin_handlers(recording) }}
    {% elif 'twilio_daily_sip_dialout' in transports %}
{{ handlers.twilio_daily_sip_dialout_handlers(recording) }}
    {% else %}
{{ handlers.standard_handlers(recording) }}
    {% endif %}

    {# Feature-specific event handlers #}
    {% if transcription %}
{{ handlers.transcription_handler() }}
    {% endif %}

    {% if recording %}
{{ handlers.recording_handler() }}
    {% endif %}

    runner = PipelineRunner(handle_sigint=False)

    await runner.run(task)


async def bot(runner_args: RunnerArguments):
    """Main bot entry point."""
    {% if enable_krisp %}
    # Krisp is available when deployed to Pipecat Cloud
    if os.environ.get("ENV") != "local":
        from pipecat.audio.filters.krisp_filter import KrispFilter

        krisp_filter = KrispFilter()
    else:
        krisp_filter = None
    {% endif %}

    {# Bot entry point - use match/case for clean transport selection #}
    {% if 'daily_pstn_dialin' in transports or 'daily_pstn_dialout' in transports %}
    {# Daily PSTN has its own special flow with server.py, so it doesn't use match/case #}
{% include 'server/_blocks/bot_entry_daily_pstn.jinja2' %}
    {% elif 'twilio_daily_sip_dialin' in transports or 'twilio_daily_sip_dialout' in transports %}
    {# Twilio + Daily SIP has its own special flow with server.py, so it doesn't use match/case #}
{% include 'server/_blocks/bot_entry_twilio_daily_sip.jinja2' %}
    {% else %}
    transport = None

    {# For other transports, use match/case on runner_args type #}
    match runner_args:
        {% if 'daily' in transports %}
        case DailyRunnerArguments():
{% include 'server/_blocks/bot_entry_daily_webrtc.jinja2' %}
        {% endif %}
        {% if 'smallwebrtc' in transports %}
        case SmallWebRTCRunnerArguments():
{% include 'server/_blocks/bot_entry_smallwebrtc.jinja2' %}
        {% endif %}
        {% if 'twilio' in transports or 'telnyx' in transports or 'plivo' in transports or 'exotel' in transports %}
        case WebSocketRunnerArguments():
            {% if 'twilio' in transports %}
{% include 'server/_blocks/bot_entry_twilio.jinja2' %}
            {% elif 'telnyx' in transports %}
{% include 'server/_blocks/bot_entry_telnyx.jinja2' %}
            {% elif 'plivo' in transports %}
{% include 'server/_blocks/bot_entry_plivo.jinja2' %}
            {% elif 'exotel' in transports %}
{% include 'server/_blocks/bot_entry_exotel.jinja2' %}
            {% endif %}
        {% endif %}
        case _:
            logger.error(f"Unsupported runner arguments type: {type(runner_args)}")
            return

    await run_bot(transport)
    {% endif %}


if __name__ == "__main__":
    from pipecat.runner.run import main

    main()
