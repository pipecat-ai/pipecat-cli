#
# Copyright (c) 2024â€“2025, Daily
#
# SPDX-License-Identifier: BSD 2-Clause License
#

"""{{ project_name }} - Pipecat Voice Agent.

This bot uses a realtime pipeline: Speech-to-Speech with integrated LLM

Generated by Pipecat CLI

Required AI services:
{% if realtime_service %}
- {{ realtime_service.replace('_realtime', '').title() }} (Realtime Speech-to-Speech)
{% endif %}

Run the bot using::
    uv run bot.py
"""

{# Import macros for composition #}
{% import 'server/_macros/event_handlers.jinja2' as handlers %}
{% import 'server/_macros/pipeline_components.jinja2' as pipeline %}
{% import 'server/_macros/helper_functions.jinja2' as helpers %}

{# Standard imports #}
{{ imports|join('\n') }}

{# Daily PSTN dial-in specific imports #}
{% if 'daily_pstn' in transports and daily_pstn_mode == 'dial-in' %}
from server_utils import AgentRequest
{% endif %}

load_dotenv(override=True)

{% if recording %}
{{ helpers.save_audio_file_function() }}
{% endif %}


async def run_bot(transport: BaseTransport, runner_args: RunnerArguments):
    """Main bot logic."""
    logger.info("Starting bot")

    # Realtime LLM service (handles STT, LLM, and TTS internally)
    {% if realtime_service and realtime_service in service_configs %}
    {{ service_configs[realtime_service] }}
    {% endif %}

{{ helpers.setup_context() }}

{{ helpers.setup_feature_processors(recording, transcription, bot_type) }}
    
    # Pipeline - assembled from reusable components
{{ pipeline.realtime_pipeline(bot_type, transcription, recording) }}

    task = PipelineTask(
        pipeline,
        params=PipelineParams(
            enable_metrics=True,
            enable_usage_metrics=True,
        ),
        {% if bot_type == 'web' or enable_observability %}
        observers=[
            {% if bot_type == 'web' %}
            RTVIObserver(rtvi),
            {% endif %}
            {% if enable_observability %}
            WhiskerObserver(pipeline),
            TailObserver(),
            {% endif %}
        ],
        {% endif %}
    )

    {# Event handlers - use macros based on transport type #}
    {% if 'daily_pstn' in transports and daily_pstn_mode == 'dial-in' %}
{{ handlers.daily_pstn_dialin_handlers() }}
    {% elif 'daily_pstn' in transports and daily_pstn_mode == 'dial-out' %}
{{ handlers.daily_pstn_dialout_handlers() }}
    {% else %}
{{ handlers.standard_handlers() }}
    {% endif %}

    {# Feature-specific event handlers #}
    {% if transcription %}
{{ handlers.transcription_handler() }}
    {% endif %}

    {% if recording %}
{{ handlers.recording_handler() }}
    {% endif %}

    runner = PipelineRunner(handle_sigint=runner_args.handle_sigint)

    await runner.run(task)


async def bot(runner_args: RunnerArguments):
    """Main bot entry point."""
    {# Bot entry point - use blocks based on transport type #}
    {% if 'daily_pstn' in transports and daily_pstn_mode == 'dial-in' %}
{% include 'server/_blocks/bot_entry_daily_pstn_dialin.jinja2' %}
    {% else %}
{% include 'server/_blocks/bot_entry_standard.jinja2' %}
    {% endif %}


if __name__ == "__main__":
    from pipecat.runner.run import main

    main()
